library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity tcp_server is
  generic (
    SERVER_MAC  : std_logic_vector(47 downto 0);
    SERVER_IP   : std_logic_vector(31 downto 0);
    SERVER_PORT : std_logic_vector(15 downto 0)
  );
  port (
    clock        : in  std_logic;
    reset        : in  std_logic;

    -- status
    is_connected : out std_logic;
    client_mac   : out std_logic_vector(47 downto 0);
    client_ip    : out std_logic_vector(31 downto 0);
    client_port  : out std_logic_vector(15 downto 0);

    -- Avalon-ST RX
    in_data      : in  std_logic_vector(7 downto 0);
    in_valid     : in  std_logic;
    in_sop       : in  std_logic;
    in_eop       : in  std_logic;
    in_ready     : out std_logic;

    -- Avalon-ST TX
    out_data     : out std_logic_vector(7 downto 0);
    out_valid    : out std_logic;
    out_sop      : out std_logic;
    out_eop      : out std_logic;
    out_ready    : in  std_logic
  );
end entity;

architecture rtl of tcp_server is

  type state_t is (S_IDLE, S_SYN_RECV, S_SYNACK_SEND, S_WAIT_ACK, S_CONNECTED);
  signal state, next_state : state_t;

  -- internal buffers
  signal rx_buffer : std_logic_vector(255 downto 0); -- simplistic
  signal tx_buffer : std_logic_vector(255 downto 0);

  signal rx_count  : integer range 0 to 255 := 0;
  signal tx_count  : integer range 0 to 255 := 0;

  -- connection info
  signal client_mac_r  : std_logic_vector(47 downto 0) := (others => '0');
  signal client_ip_r   : std_logic_vector(31 downto 0) := (others => '0');
  signal client_port_r : std_logic_vector(15 downto 0) := (others => '0');

begin
  -- outputs
  client_mac   <= client_mac_r;
  client_ip    <= client_ip_r;
  client_port  <= client_port_r;
  is_connected <= '1' when state = S_CONNECTED else '0';

  -- RX ready always
  in_ready <= '1';

  -- FSM
  process(clock, reset)
  begin
    if reset = '1' then
      state <= S_IDLE;
      rx_count <= 0;
      tx_count <= 0;
      out_valid <= '0';
      out_sop   <= '0';
      out_eop   <= '0';
    elsif rising_edge(clock) then
      state <= next_state;

      -- RX logic: capture incoming bytes
      if in_valid = '1' then
        rx_buffer(rx_count*8+7 downto rx_count*8) <= in_data;
        rx_count <= rx_count + 1;
        if in_eop = '1' then
          rx_count <= 0;
        end if;
      end if;

      -- TX handshake
      if out_ready = '1' then
        out_valid <= '0';
      end if;
    end if;
  end process;

  -- Next-state logic
  process(state, in_valid, in_sop, in_eop, rx_buffer)
  begin
    next_state <= state;
    case state is
      when S_IDLE =>
        -- Äekamo SYN paket
        if in_valid = '1' and in_sop = '1' then
          -- ovdje bi se parsirao TCP header i izvukli client_mac, client_ip, client_port
          client_mac_r  <= x"112233445566"; -- placeholder
          client_ip_r   <= x"C0A80101";     -- 192.168.1.1
          client_port_r <= x"1234";
          next_state    <= S_SYN_RECV;
        end if;

      when S_SYN_RECV =>
        -- pripremi SYN-ACK odgovor
        tx_buffer <= x"DEADBEEF"; -- placeholder TCP SYN-ACK segment
        out_data  <= tx_buffer(7 downto 0);
        out_valid <= '1';
        out_sop   <= '1';
        out_eop   <= '1';
        next_state<= S_SYNACK_SEND;

      when S_SYNACK_SEND =>
        if out_ready = '1' then
          next_state <= S_WAIT_ACK;
        end if;

      when S_WAIT_ACK =>
        if in_valid = '1' and in_sop = '1' then
          -- ACK od klijenta
          next_state <= S_CONNECTED;
        end if;

      when S_CONNECTED =>
        -- konekcija uspostavljena
        next_state <= S_CONNECTED;

      when others =>
        next_state <= S_IDLE;
    end case;
  end process;

end architecture;
